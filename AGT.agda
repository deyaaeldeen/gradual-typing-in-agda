module AGT where

  open import Agda.Primitive renaming (_‚äî_ to _‚äç_)
  open import Types
  open import Labels
  open import Data.Product using (_√ó_; proj‚ÇÅ; proj‚ÇÇ; Œ£; Œ£-syntax)
     renaming (_,_ to ‚ü®_,_‚ü©)
  open import Data.Nat using (‚Ñï; zero; suc)
  open import Data.Sum using (_‚äé_; inj‚ÇÅ; inj‚ÇÇ)
  open import Data.Empty using (‚ä•; ‚ä•-elim)
  open import Relation.Binary.PropositionalEquality
     using (_‚â°_;_‚â¢_; refl; trans; sym; cong; cong‚ÇÇ; cong-app)
  open import Relation.Nullary using (¬¨_; Dec; yes; no)
  open import Relation.Nullary.Negation using (contradiction)

  data SType : Set where
    `_ : Base ‚Üí SType
    _‚áí_ : SType ‚Üí SType ‚Üí SType
    _`√ó_ : SType ‚Üí SType ‚Üí SType
    _`‚äé_ : SType ‚Üí SType ‚Üí SType

  data _‚å¢_ : SType ‚Üí SType ‚Üí Set where
    base‚å¢ : ‚àÄ{Œπ : Base} ‚Üí (` Œπ) ‚å¢ (` Œπ)
    fun‚å¢ : ‚àÄ{A B A' B'}
        -------------------
      ‚Üí (A ‚áí B) ‚å¢ (A' ‚áí B')
    pair‚å¢ : ‚àÄ{A B A' B'}
        -------------------
      ‚Üí (A `√ó B) ‚å¢ (A' `√ó B')
    sum‚å¢ : ‚àÄ{A B A' B'}
        -------------------
      ‚Üí (A `‚äé B) ‚å¢ (A' `‚äé B')
      
  {- Concretization -}

  data Conc : Type ‚Üí SType ‚Üí Set where
    c-base : ‚àÄ{Œπ} ‚Üí Conc (` Œπ) (` Œπ)
    c-fun : ‚àÄ{T‚ÇÅ T‚ÇÇ : Type} {S‚ÇÅ S‚ÇÇ : SType}
       ‚Üí Conc T‚ÇÅ S‚ÇÅ  ‚Üí  Conc T‚ÇÇ S‚ÇÇ
         -------------------------
       ‚Üí Conc (T‚ÇÅ ‚áí T‚ÇÇ) (S‚ÇÅ ‚áí S‚ÇÇ)
    c-pair : ‚àÄ{T‚ÇÅ T‚ÇÇ : Type} {S‚ÇÅ S‚ÇÇ : SType}
       ‚Üí Conc T‚ÇÅ S‚ÇÅ  ‚Üí  Conc T‚ÇÇ S‚ÇÇ
         -------------------------
       ‚Üí Conc (T‚ÇÅ `√ó T‚ÇÇ) (S‚ÇÅ `√ó S‚ÇÇ)
    c-sum : ‚àÄ{T‚ÇÅ T‚ÇÇ : Type} {S‚ÇÅ S‚ÇÇ : SType}
       ‚Üí Conc T‚ÇÅ S‚ÇÅ  ‚Üí  Conc T‚ÇÇ S‚ÇÇ
         -------------------------
       ‚Üí Conc (T‚ÇÅ `‚äé T‚ÇÇ) (S‚ÇÅ `‚äé S‚ÇÇ)
    c-unk : ‚àÄ{S} ‚Üí Conc ‚ãÜ S

  infix 6 _`‚äë_
  data _`‚äë_ : Type ‚Üí Type ‚Üí Set where
    prec : ‚àÄ{A B}
          ‚Üí (‚àÄ{S} ‚Üí Conc A S ‚Üí Conc B S)
            ----------------------------
          ‚Üí A `‚äë B

  conc : (A : Type) ‚Üí Œ£[ S ‚àà SType ] Conc A S
  conc ‚ãÜ = ‚ü® ` ùîπ , c-unk ‚ü©
  conc (` Œπ) = ‚ü® ` Œπ , c-base ‚ü©
  conc (A ‚áí B) with conc A | conc B
  ... | ‚ü® A' , ca ‚ü© | ‚ü® B' , cb ‚ü© =
      ‚ü® A' ‚áí B' , c-fun ca cb ‚ü©
  conc (A `√ó B) with conc A | conc B
  ... | ‚ü® A' , ca ‚ü© | ‚ü® B' , cb ‚ü© =
      ‚ü® A' `√ó B' , c-pair ca cb ‚ü©
  conc (A `‚äé B) with conc A | conc B
  ... | ‚ü® A' , ca ‚ü© | ‚ü® B' , cb ‚ü© =
      ‚ü® A' `‚äé B' , c-sum ca cb ‚ü©

  prec-unk-inv : ‚àÄ{A}
    ‚Üí ‚ãÜ `‚äë A
      ------
    ‚Üí A ‚â° ‚ãÜ
  prec-unk-inv {‚ãÜ} (prec f) = refl
  prec-unk-inv {` Œπ} (prec f) with f {` Œπ ‚áí ` Œπ} c-unk
  ... | ()
  prec-unk-inv {A ‚áí A‚ÇÅ} (prec f) with f {` Nat} c-unk
  ... | ()
  prec-unk-inv {A `√ó A‚ÇÅ} (prec f) with f {` Nat} c-unk
  ... | ()
  prec-unk-inv {A `‚äé A‚ÇÅ} (prec f) with f {` Nat} c-unk
  ... | ()

  prec-base-inv : ‚àÄ{A Œπ}
    ‚Üí ` Œπ `‚äë A
      ---------------
    ‚Üí A ‚â° ` Œπ ‚äé A ‚â° ‚ãÜ
  prec-base-inv {‚ãÜ} (prec f) = inj‚ÇÇ refl
  prec-base-inv {` Œπ} {Œπ'} (prec f) with f {` Œπ'} c-base
  ... | c-base = inj‚ÇÅ refl
  prec-base-inv {A ‚áí A‚ÇÅ} {Œπ} (prec f) with f {` Œπ} c-base
  ... | ()
  prec-base-inv {A `√ó A‚ÇÅ} {Œπ} (prec f) with f {` Œπ} c-base
  ... | ()
  prec-base-inv {A `‚äé A‚ÇÅ} {Œπ} (prec f) with f {` Œπ} c-base
  ... | ()

  prec-fun-inv : ‚àÄ{A‚ÇÅ A‚ÇÇ B‚ÇÅ B‚ÇÇ}
     ‚Üí (A‚ÇÅ ‚áí A‚ÇÇ) `‚äë (B‚ÇÅ ‚áí B‚ÇÇ)
       -----------------------
     ‚Üí (A‚ÇÅ `‚äë B‚ÇÅ) √ó (A‚ÇÇ `‚äë B‚ÇÇ)
  prec-fun-inv {A‚ÇÅ}{A‚ÇÇ}{B‚ÇÅ}{B‚ÇÇ} (prec f) =
    ‚ü® prec g , prec h ‚ü©
    where
    g : {S : SType} ‚Üí Conc A‚ÇÅ S ‚Üí Conc B‚ÇÅ S
    g ca with conc A‚ÇÇ
    ... | ‚ü® A‚ÇÇ' , ca2 ‚ü© with f (c-fun ca ca2)
    ... | c-fun a b = a
    
    h : {S : SType} ‚Üí Conc A‚ÇÇ S ‚Üí Conc B‚ÇÇ S
    h ca with conc A‚ÇÅ
    ... | ‚ü® A' , ca1 ‚ü© with f (c-fun ca1 ca )
    ... | c-fun a b = b

  prec-left-fun-inv : ‚àÄ{A‚ÇÅ A‚ÇÇ B}
     ‚Üí (A‚ÇÅ ‚áí A‚ÇÇ) `‚äë B
       -----------------------
     ‚Üí (Œ£[ B‚ÇÅ ‚àà Type ] Œ£[ B‚ÇÇ ‚àà Type ] (B ‚â° B‚ÇÅ ‚áí B‚ÇÇ) √ó (A‚ÇÅ `‚äë B‚ÇÅ) √ó (A‚ÇÇ `‚äë B‚ÇÇ))
       ‚äé B ‚â° ‚ãÜ
  prec-left-fun-inv {A‚ÇÅ} {A‚ÇÇ} {‚ãÜ} (prec f) = inj‚ÇÇ refl
  prec-left-fun-inv {A‚ÇÅ} {A‚ÇÇ} {` Œπ} (prec f)
      with conc A‚ÇÅ | conc A‚ÇÇ
  ... | ‚ü® A‚ÇÅ' , ca1 ‚ü© | ‚ü® A‚ÇÇ' , ca2 ‚ü©
      with f (c-fun ca1 ca2)
  ... | ()
  prec-left-fun-inv {A‚ÇÅ} {A‚ÇÇ} {B‚ÇÅ ‚áí B‚ÇÇ} (prec f) with prec-fun-inv (prec f)
  ... | ‚ü® a1b1 , a2b2 ‚ü© =
    inj‚ÇÅ ‚ü® B‚ÇÅ , ‚ü® B‚ÇÇ , ‚ü® refl , ‚ü® a1b1 , a2b2 ‚ü© ‚ü© ‚ü© ‚ü©
  prec-left-fun-inv {A‚ÇÅ} {A‚ÇÇ} {B `√ó B‚ÇÅ} (prec f)
      with conc A‚ÇÅ | conc A‚ÇÇ
  ... | ‚ü® A‚ÇÅ' , ca1 ‚ü© | ‚ü® A‚ÇÇ' , ca2 ‚ü©
      with f (c-fun ca1 ca2)
  ... | ()
  prec-left-fun-inv {A‚ÇÅ} {A‚ÇÇ} {B `‚äé B‚ÇÅ} (prec f)
      with conc A‚ÇÅ | conc A‚ÇÇ
  ... | ‚ü® A‚ÇÅ' , ca1 ‚ü© | ‚ü® A‚ÇÇ' , ca2 ‚ü©
      with f (c-fun ca1 ca2)
  ... | ()

  prec-pair-inv : ‚àÄ{A‚ÇÅ A‚ÇÇ B‚ÇÅ B‚ÇÇ}
     ‚Üí (A‚ÇÅ `√ó A‚ÇÇ) `‚äë (B‚ÇÅ `√ó B‚ÇÇ)
       -----------------------
     ‚Üí (A‚ÇÅ `‚äë B‚ÇÅ) √ó (A‚ÇÇ `‚äë B‚ÇÇ)
  prec-pair-inv {A‚ÇÅ}{A‚ÇÇ}{B‚ÇÅ}{B‚ÇÇ} (prec f) =
    ‚ü® prec g , prec h ‚ü©
    where
    g : {S : SType} ‚Üí Conc A‚ÇÅ S ‚Üí Conc B‚ÇÅ S
    g ca with conc A‚ÇÇ
    ... | ‚ü® A‚ÇÇ' , ca2 ‚ü© with f (c-pair ca ca2)
    ... | c-pair a b = a
    
    h : {S : SType} ‚Üí Conc A‚ÇÇ S ‚Üí Conc B‚ÇÇ S
    h ca with conc A‚ÇÅ
    ... | ‚ü® A' , ca1 ‚ü© with f (c-pair ca1 ca )
    ... | c-pair a b = b

  prec-left-pair-inv : ‚àÄ{A‚ÇÅ A‚ÇÇ B}
     ‚Üí (A‚ÇÅ `√ó A‚ÇÇ) `‚äë B
       -----------------------
     ‚Üí (Œ£[ B‚ÇÅ ‚àà Type ] Œ£[ B‚ÇÇ ‚àà Type ] (B ‚â° B‚ÇÅ `√ó B‚ÇÇ) √ó (A‚ÇÅ `‚äë B‚ÇÅ) √ó (A‚ÇÇ `‚äë B‚ÇÇ))
       ‚äé B ‚â° ‚ãÜ
  prec-left-pair-inv {A‚ÇÅ} {A‚ÇÇ} {‚ãÜ} (prec f) = inj‚ÇÇ refl
  prec-left-pair-inv {A‚ÇÅ} {A‚ÇÇ} {` Œπ} (prec f)
      with conc A‚ÇÅ | conc A‚ÇÇ
  ... | ‚ü® A‚ÇÅ' , ca1 ‚ü© | ‚ü® A‚ÇÇ' , ca2 ‚ü©
      with f (c-pair ca1 ca2)
  ... | ()
  prec-left-pair-inv {A‚ÇÅ} {A‚ÇÇ} {B ‚áí B‚ÇÅ} (prec f)
      with conc A‚ÇÅ | conc A‚ÇÇ
  ... | ‚ü® A‚ÇÅ' , ca1 ‚ü© | ‚ü® A‚ÇÇ' , ca2 ‚ü©
      with f (c-pair ca1 ca2)
  ... | ()
  prec-left-pair-inv {A‚ÇÅ} {A‚ÇÇ} {B‚ÇÅ `√ó B‚ÇÇ} (prec f) with prec-pair-inv (prec f)
  ... | ‚ü® a1b1 , a2b2 ‚ü© =
    inj‚ÇÅ ‚ü® B‚ÇÅ , ‚ü® B‚ÇÇ , ‚ü® refl , ‚ü® a1b1 , a2b2 ‚ü© ‚ü© ‚ü© ‚ü©
  prec-left-pair-inv {A‚ÇÅ} {A‚ÇÇ} {B `‚äé B‚ÇÅ} (prec f)
      with conc A‚ÇÅ | conc A‚ÇÇ
  ... | ‚ü® A‚ÇÅ' , ca1 ‚ü© | ‚ü® A‚ÇÇ' , ca2 ‚ü©
      with f (c-pair ca1 ca2)
  ... | ()

  prec-sum-inv : ‚àÄ{A‚ÇÅ A‚ÇÇ B‚ÇÅ B‚ÇÇ}
     ‚Üí (A‚ÇÅ `‚äé A‚ÇÇ) `‚äë (B‚ÇÅ `‚äé B‚ÇÇ)
       -----------------------
     ‚Üí (A‚ÇÅ `‚äë B‚ÇÅ) √ó (A‚ÇÇ `‚äë B‚ÇÇ)
  prec-sum-inv {A‚ÇÅ}{A‚ÇÇ}{B‚ÇÅ}{B‚ÇÇ} (prec f) =
    ‚ü® prec g , prec h ‚ü©
    where
    g : {S : SType} ‚Üí Conc A‚ÇÅ S ‚Üí Conc B‚ÇÅ S
    g ca with conc A‚ÇÇ
    ... | ‚ü® A‚ÇÇ' , ca2 ‚ü© with f (c-sum ca ca2)
    ... | c-sum a b = a
    
    h : {S : SType} ‚Üí Conc A‚ÇÇ S ‚Üí Conc B‚ÇÇ S
    h ca with conc A‚ÇÅ
    ... | ‚ü® A' , ca1 ‚ü© with f (c-sum ca1 ca )
    ... | c-sum a b = b

  prec-left-sum-inv : ‚àÄ{A‚ÇÅ A‚ÇÇ B}
     ‚Üí (A‚ÇÅ `‚äé A‚ÇÇ) `‚äë B
       -----------------------
     ‚Üí (Œ£[ B‚ÇÅ ‚àà Type ] Œ£[ B‚ÇÇ ‚àà Type ] (B ‚â° B‚ÇÅ `‚äé B‚ÇÇ) √ó (A‚ÇÅ `‚äë B‚ÇÅ) √ó (A‚ÇÇ `‚äë B‚ÇÇ))
       ‚äé B ‚â° ‚ãÜ
  prec-left-sum-inv {A‚ÇÅ} {A‚ÇÇ} {‚ãÜ} (prec f) = inj‚ÇÇ refl
  prec-left-sum-inv {A‚ÇÅ} {A‚ÇÇ} {` Œπ} (prec f)
      with conc A‚ÇÅ | conc A‚ÇÇ
  ... | ‚ü® A‚ÇÅ' , ca1 ‚ü© | ‚ü® A‚ÇÇ' , ca2 ‚ü©
      with f (c-sum ca1 ca2)
  ... | ()
  prec-left-sum-inv {A‚ÇÅ} {A‚ÇÇ} {B ‚áí B‚ÇÅ} (prec f)
      with conc A‚ÇÅ | conc A‚ÇÇ
  ... | ‚ü® A‚ÇÅ' , ca1 ‚ü© | ‚ü® A‚ÇÇ' , ca2 ‚ü©
      with f (c-sum ca1 ca2)
  ... | ()
  prec-left-sum-inv {A‚ÇÅ} {A‚ÇÇ} {B `√ó B‚ÇÅ} (prec f)
      with conc A‚ÇÅ | conc A‚ÇÇ
  ... | ‚ü® A‚ÇÅ' , ca1 ‚ü© | ‚ü® A‚ÇÇ' , ca2 ‚ü©
      with f (c-sum ca1 ca2)
  ... | ()
  prec-left-sum-inv {A‚ÇÅ} {A‚ÇÇ} {B‚ÇÅ `‚äé B‚ÇÇ} (prec f) with prec-sum-inv (prec f)
  ... | ‚ü® a1b1 , a2b2 ‚ü© =
    inj‚ÇÅ ‚ü® B‚ÇÅ , ‚ü® B‚ÇÇ , ‚ü® refl , ‚ü® a1b1 , a2b2 ‚ü© ‚ü© ‚ü© ‚ü©

  le-implies-prec : ‚àÄ {A B} ‚Üí A ‚äë B ‚Üí B `‚äë A
  
  le-implies-prec unk‚äë = prec (Œª {S} _ ‚Üí c-unk)
  le-implies-prec base‚äë = prec (Œª {S} z ‚Üí z)
  le-implies-prec (fun‚äë le‚ÇÅ le‚ÇÇ)
     with le-implies-prec le‚ÇÅ | le-implies-prec le‚ÇÇ
  ... | prec imp1 | prec imp2 =
     prec Œª { (c-fun x y) ‚Üí c-fun (imp1 x) (imp2 y) }
  le-implies-prec (pair‚äë le‚ÇÅ le‚ÇÇ)
     with le-implies-prec le‚ÇÅ | le-implies-prec le‚ÇÇ
  ... | prec imp1 | prec imp2 =
     prec Œª { (c-pair x y) ‚Üí c-pair (imp1 x) (imp2 y) }
  le-implies-prec (sum‚äë le‚ÇÅ le‚ÇÇ)
     with le-implies-prec le‚ÇÅ | le-implies-prec le‚ÇÇ
  ... | prec imp1 | prec imp2 =
     prec Œª { (c-sum x y) ‚Üí c-sum (imp1 x) (imp2 y) }

  prec-implies-le : ‚àÄ{A B} ‚Üí A `‚äë B ‚Üí B ‚äë A
  prec-implies-le {‚ãÜ} {B} (prec f) with prec-unk-inv (prec f)
  ... | eq rewrite eq = unk‚äë
  prec-implies-le {` Œπ} {B} (prec f) with prec-base-inv (prec f)
  ... | inj‚ÇÅ eq rewrite eq = base‚äë
  ... | inj‚ÇÇ eq rewrite eq = unk‚äë
  prec-implies-le {A‚ÇÅ ‚áí A‚ÇÇ} {B} (prec f) with prec-left-fun-inv (prec f)
  ... | inj‚ÇÅ ‚ü® B‚ÇÅ , ‚ü® B‚ÇÇ , ‚ü® eq , ‚ü® a1b1 , a2b2 ‚ü© ‚ü© ‚ü© ‚ü© rewrite eq =
        fun‚äë (prec-implies-le a1b1) (prec-implies-le a2b2)
  ... | inj‚ÇÇ eq rewrite eq = unk‚äë
  prec-implies-le {A‚ÇÅ `√ó A‚ÇÇ} {B} (prec f) with prec-left-pair-inv (prec f)
  ... | inj‚ÇÅ ‚ü® B‚ÇÅ , ‚ü® B‚ÇÇ , ‚ü® eq , ‚ü® a1b1 , a2b2 ‚ü© ‚ü© ‚ü© ‚ü© rewrite eq =
        pair‚äë (prec-implies-le a1b1) (prec-implies-le a2b2)
  ... | inj‚ÇÇ eq rewrite eq = unk‚äë
  prec-implies-le {A‚ÇÅ `‚äé A‚ÇÇ} {B} (prec f) with prec-left-sum-inv (prec f)
  ... | inj‚ÇÅ ‚ü® B‚ÇÅ , ‚ü® B‚ÇÇ , ‚ü® eq , ‚ü® a1b1 , a2b2 ‚ü© ‚ü© ‚ü© ‚ü© rewrite eq =
        sum‚äë (prec-implies-le a1b1) (prec-implies-le a2b2)
  ... | inj‚ÇÇ eq rewrite eq = unk‚äë

  data _~'_ : Type ‚Üí Type ‚Üí Set where
    cons : ‚àÄ {A B : Type} {S : SType}
           ‚Üí Conc A S ‚Üí Conc B S
             -------------------
           ‚Üí A ~' B

  cons-implies-ceq : ‚àÄ {A B} ‚Üí A ~ B ‚Üí A ~' B
  cons-implies-ceq {.‚ãÜ}{B} unk~L with conc B
  ... | ‚ü® B' , cb ‚ü© = cons c-unk cb
  cons-implies-ceq {A}{‚ãÜ} unk~R with conc A
  ... | ‚ü® A' , ca ‚ü© = cons ca c-unk
  cons-implies-ceq base~ = cons c-base c-base
  cons-implies-ceq {A‚ÇÅ ‚áí A‚ÇÇ}{B‚ÇÅ ‚áí B‚ÇÇ} (fun~ cns‚ÇÅ cns‚ÇÇ)
      with cons-implies-ceq cns‚ÇÅ | cons-implies-ceq cns‚ÇÇ
  ... | cons{S = S‚ÇÅ} c1 c2 | cons{S = S‚ÇÇ} c3 c4 =
    cons (c-fun c1 c3) (c-fun c2 c4)
  cons-implies-ceq {A‚ÇÅ `√ó A‚ÇÇ}{B‚ÇÅ `√ó B‚ÇÇ} (pair~ cns‚ÇÅ cns‚ÇÇ)
      with cons-implies-ceq cns‚ÇÅ | cons-implies-ceq cns‚ÇÇ
  ... | cons{S = S‚ÇÅ} c1 c2 | cons{S = S‚ÇÇ} c3 c4 =
    cons (c-pair c1 c3) (c-pair c2 c4)
  cons-implies-ceq {A‚ÇÅ `‚äé A‚ÇÇ}{B‚ÇÅ `‚äé B‚ÇÇ} (sum~ cns‚ÇÅ cns‚ÇÇ)
      with cons-implies-ceq cns‚ÇÅ | cons-implies-ceq cns‚ÇÇ
  ... | cons{S = S‚ÇÅ} c1 c2 | cons{S = S‚ÇÇ} c3 c4 =
    cons (c-sum c1 c3) (c-sum c2 c4)

  {- to do: ceq-implies-cons -}

  {- Abstraction -}

  data AllFuns : (SType ‚Üí Set) ‚Üí Set where
    funs : ‚àÄ{P}
      ‚Üí (‚àÄ{T : SType} ‚Üí P T ‚Üí Œ£[ T‚ÇÅ ‚àà SType ] Œ£[ T‚ÇÇ ‚àà SType ]
            T ‚â° T‚ÇÅ ‚áí T‚ÇÇ)
        -----------------------------------------------------
      ‚Üí AllFuns P

  data Dom : (SType ‚Üí Set) ‚Üí (SType ‚Üí Set) ‚Üí Set where
    dom : ‚àÄ{P P‚ÇÅ : (SType ‚Üí Set)}
      ‚Üí (‚àÄ{T‚ÇÅ} ‚Üí P‚ÇÅ T‚ÇÅ ‚Üí Œ£[ T‚ÇÇ ‚àà SType ] P (T‚ÇÅ ‚áí T‚ÇÇ))
      ‚Üí (‚àÄ{T‚ÇÅ T‚ÇÇ} ‚Üí P (T‚ÇÅ ‚áí T‚ÇÇ) ‚Üí P‚ÇÅ T‚ÇÅ)
        ---------------------------------------------
      ‚Üí Dom P P‚ÇÅ

  data Cod : (SType ‚Üí Set) ‚Üí (SType ‚Üí Set) ‚Üí Set where
    cod : ‚àÄ{P P‚ÇÇ}
      ‚Üí (‚àÄ{T‚ÇÇ} ‚Üí P‚ÇÇ T‚ÇÇ ‚Üí Œ£[ T‚ÇÅ ‚àà SType ] P (T‚ÇÅ ‚áí T‚ÇÇ))
      ‚Üí (‚àÄ{T‚ÇÅ T‚ÇÇ} ‚Üí P (T‚ÇÅ ‚áí T‚ÇÇ) ‚Üí P‚ÇÇ T‚ÇÇ)
        ---------------------------------------------
      ‚Üí Cod P P‚ÇÇ

  data Abs : (SType ‚Üí Set) ‚Üí Type ‚Üí Set‚ÇÅ where
    abs-base : ‚àÄ{P : SType ‚Üí Set} {Œπ : Base}
      ‚Üí (‚àÄ{T : SType} ‚Üí P T ‚Üí T ‚â° ` Œπ)
        -------------------------------
      ‚Üí Abs P (` Œπ)
    abs-fun : ‚àÄ{P P‚ÇÅ P‚ÇÇ : SType ‚Üí Set}{A B : Type}
      ‚Üí AllFuns P
      ‚Üí Dom P P‚ÇÅ  ‚Üí   Abs P‚ÇÅ A
      ‚Üí Cod P P‚ÇÇ  ‚Üí   Abs P‚ÇÇ B
        ----------------------
      ‚Üí Abs P (A ‚áí B)
    abs-any : ‚àÄ{P : SType ‚Üí Set} {S T : SType}
      ‚Üí ¬¨ (S ‚å¢ T)
      ‚Üí P S ‚Üí P T
        ---------------
      ‚Üí Abs P ‚ãÜ

  _‚äÜ_ : (SType ‚Üí Set) ‚Üí (SType ‚Üí Set) ‚Üí Set
  P ‚äÜ P' = ‚àÄ{T : SType} ‚Üí P T ‚Üí P' T


  dom-dom : ‚àÄ {P P' : SType ‚Üí Set} {T T' : SType}
    ‚Üí Dom P P'  ‚Üí  P (T ‚áí T')
      -----------------------
    ‚Üí P' T
  dom-dom (dom f g) p-tt' = g p-tt'

  cod-cod : ‚àÄ {P P' : SType ‚Üí Set} {T T' : SType}
    ‚Üí Cod P P'  ‚Üí  P (T ‚áí T')
      -----------------------
    ‚Üí P' T'
  cod-cod (cod f g) p-tt' = g p-tt'


  conc-abs-sound : ‚àÄ{P : SType ‚Üí Set}{A : Type}
     ‚Üí Abs P A  
       ----------
     ‚Üí P ‚äÜ Conc A
  conc-abs-sound (abs-base p-base) {T} pt
    rewrite p-base {T} pt = c-base
  conc-abs-sound (abs-fun allfun dom-p abs-a cod-p abs-b) pt
      with allfun
  ... | funs af
      with af pt
  ... | ‚ü® T‚ÇÅ , ‚ü® T‚ÇÇ , eq ‚ü© ‚ü© rewrite eq =
        let ih1 = conc-abs-sound abs-a in
        let ih2 = conc-abs-sound abs-b in
        c-fun (ih1 (dom-dom dom-p pt)) (ih2 (cod-cod cod-p pt))
  conc-abs-sound (abs-any a b c) pt = c-unk

  c-any-base  : ‚àÄ{A Œπ}
     ‚Üí Conc A (` Œπ)
     ‚Üí A ‚â° (` Œπ) ‚äé A ‚â° ‚ãÜ
  c-any-base c-base = inj‚ÇÅ refl
  c-any-base c-unk = inj‚ÇÇ refl

  c-any-fun  : ‚àÄ{A T‚ÇÅ T‚ÇÇ}
     ‚Üí Conc A (T‚ÇÅ ‚áí T‚ÇÇ)
     ‚Üí (Œ£[ A‚ÇÅ ‚àà Type ] Œ£[ A‚ÇÇ ‚àà Type ] A ‚â° A‚ÇÅ ‚áí A‚ÇÇ √ó Conc A‚ÇÅ T‚ÇÅ √ó Conc A‚ÇÇ T‚ÇÇ)
       ‚äé A ‚â° ‚ãÜ
  c-any-fun (c-fun{T‚ÇÅ}{T‚ÇÇ} c c‚ÇÅ) =
      inj‚ÇÅ ‚ü® T‚ÇÅ , ‚ü® T‚ÇÇ , ‚ü® refl , ‚ü® c , c‚ÇÅ ‚ü© ‚ü© ‚ü© ‚ü©
  c-any-fun c-unk = inj‚ÇÇ refl

  conc-sh-cons : ‚àÄ{A T‚ÇÅ T‚ÇÇ}
     ‚Üí Conc A T‚ÇÅ  ‚Üí  Conc A T‚ÇÇ
       -----------------------
     ‚Üí A ‚â° ‚ãÜ ‚äé (T‚ÇÅ ‚å¢ T‚ÇÇ)
  conc-sh-cons c-base c-base = inj‚ÇÇ base‚å¢
  conc-sh-cons (c-fun a-t1 a-t3) (c-fun a-t2 a-t4) = inj‚ÇÇ fun‚å¢
  conc-sh-cons (c-pair a-t1 a-t3) (c-pair a-t2 a-t4) = inj‚ÇÇ pair‚å¢
  conc-sh-cons (c-sum a-t1 a-t3) (c-sum a-t2 a-t4) = inj‚ÇÇ sum‚å¢
  conc-sh-cons c-unk a-t2 = inj‚ÇÅ refl

  abs-optimal : ‚àÄ {P : SType ‚Üí Set} {A A' : Type}
    ‚Üí (Œ£[ T ‚àà SType ] P T)
    ‚Üí P ‚äÜ Conc A  ‚Üí  Abs P A'
      -------------------------
    ‚Üí A ‚äë A'
  abs-optimal ‚ü® T , pt ‚ü© p-ca (abs-base all-base)
      with pt
  ... | pt'
      rewrite all-base pt
      with c-any-base (p-ca pt') 
  ... | inj‚ÇÅ eq rewrite eq = Refl‚äë
  ... | inj‚ÇÇ eq rewrite eq = unk‚äë
  abs-optimal ‚ü® T , pt ‚ü© p-ca
          (abs-fun{P}{P‚ÇÅ}{P‚ÇÇ}{B‚ÇÅ}{B‚ÇÇ} allf dom-pp1 abs-p1-b1 cod-p-p2 abs-p2-b2)
      with allf
  ... | funs af
      with af pt
  ... | ‚ü® T‚ÇÅ , ‚ü® T‚ÇÇ , eq ‚ü© ‚ü© rewrite eq
      with dom-pp1
  ... | dom dom-f dom-g 
      with cod-p-p2
  ... | cod cod-f cod-g 
      with c-any-fun (p-ca pt)
  ... | inj‚ÇÅ ‚ü® A‚ÇÅ , ‚ü® A‚ÇÇ , ‚ü® a=a12 , ‚ü® c1 , c2 ‚ü© ‚ü© ‚ü© ‚ü© rewrite a=a12 =
      let ih1 = abs-optimal ‚ü® T‚ÇÅ , (dom-g pt) ‚ü© p1-a1 abs-p1-b1 in
      let ih2 = abs-optimal ‚ü® T‚ÇÇ , (cod-g pt) ‚ü© p2-a2 abs-p2-b2 in
      fun‚äë ih1 ih2
      where
      p1-a1 : P‚ÇÅ ‚äÜ Conc A‚ÇÅ
      p1-a1 {T} p1t with dom-f p1t
      ... | ‚ü® T‚ÇÇ , p-tt2 ‚ü©
          with p-ca p-tt2 
      ... | c-fun c1 c2 = c1

      p2-a2 : P‚ÇÇ ‚äÜ Conc A‚ÇÇ
      p2-a2 {T} p1t with cod-f p1t
      ... | ‚ü® T‚ÇÅ , p-t1t ‚ü©
          with p-ca p-t1t 
      ... | c-fun c1 c2 = c2

  ... | inj‚ÇÇ a=unk rewrite a=unk =
      unk‚äë
  abs-optimal ‚ü® T , pt ‚ü© p-ca (abs-any a b c)
      with conc-sh-cons (p-ca b) (p-ca c) 
  ... | inj‚ÇÅ A‚â°‚ãÜ rewrite A‚â°‚ãÜ = 
        unk‚äë
  ... | inj‚ÇÇ x = 
        contradiction x a


  all-funs-conc : ‚àÄ{A} ‚Üí AllFuns (Conc A)
          ‚Üí Œ£[ A‚ÇÅ ‚àà Type ] Œ£[ A‚ÇÇ ‚àà Type ] A ‚â° A‚ÇÅ ‚áí A‚ÇÇ
  all-funs-conc {‚ãÜ} (funs f)
      with f {` Nat} c-unk
  ... | ‚ü® T‚ÇÅ , ‚ü® T‚ÇÇ , () ‚ü© ‚ü© 
  all-funs-conc {` Œπ} (funs f)
      with f {` Œπ} c-base
  ... | ‚ü® T‚ÇÅ , ‚ü® T‚ÇÇ , () ‚ü© ‚ü© 
  all-funs-conc {A‚ÇÅ ‚áí A‚ÇÇ} af = ‚ü® A‚ÇÅ , ‚ü® A‚ÇÇ , refl ‚ü© ‚ü©
  all-funs-conc {A‚ÇÅ `√ó A‚ÇÇ} (funs f)
      with conc A‚ÇÅ | conc A‚ÇÇ
  ... | ‚ü® T‚ÇÅ , cat1 ‚ü© | ‚ü® T‚ÇÇ , cat2 ‚ü© 
      with f {T‚ÇÅ `√ó T‚ÇÇ} (c-pair cat1 cat2)
  ... | ‚ü® T‚ÇÅ' , ‚ü® T‚ÇÇ' , () ‚ü© ‚ü©
  all-funs-conc {A‚ÇÅ `‚äé A‚ÇÇ} (funs f)
      with conc A‚ÇÅ | conc A‚ÇÇ
  ... | ‚ü® T‚ÇÅ , cat1 ‚ü© | ‚ü® T‚ÇÇ , cat2 ‚ü© 
      with f {T‚ÇÅ `‚äé T‚ÇÇ} (c-sum cat1 cat2)
  ... | ‚ü® T‚ÇÅ' , ‚ü® T‚ÇÇ' , () ‚ü© ‚ü©
  

  conc-abs-id : ‚àÄ{A B : Type}{P : SType ‚Üí Set}
    ‚Üí Abs (Conc A) B
      -------------------
    ‚Üí A ‚â° B
  conc-abs-id {A}{B}{P} abs-conc-ab =
    let A‚äëB = (abs-optimal {Conc A}{A}{B} (conc A) (Œª {T} z ‚Üí z)) abs-conc-ab in
    let B‚äëA = prec-implies-le (prec (conc-abs-sound abs-conc-ab)) in
    AntiSym‚äë A‚äëB B‚äëA

  {-
   Def. of interior based on Prop 15 and a little subsequent reasoning.
   -}

  data L (P : SType ‚Üí SType ‚Üí Set) (G‚ÇÅ : Type) (G‚ÇÇ : Type) : SType ‚Üí Set where
    leftp : ‚àÄ{T‚ÇÅ T‚ÇÇ : SType}
           ‚Üí Conc G‚ÇÅ T‚ÇÅ  ‚Üí  Conc G‚ÇÇ T‚ÇÇ  ‚Üí  P T‚ÇÅ T‚ÇÇ
             -------------------------------------
           ‚Üí L P G‚ÇÅ G‚ÇÇ T‚ÇÅ

  data R (P : SType ‚Üí SType ‚Üí Set) (G‚ÇÅ : Type) (G‚ÇÇ : Type) : SType ‚Üí Set where
    rightp : ‚àÄ{T‚ÇÅ T‚ÇÇ : SType}
           ‚Üí Conc G‚ÇÅ T‚ÇÅ  ‚Üí  Conc G‚ÇÇ T‚ÇÇ  ‚Üí  P T‚ÇÅ T‚ÇÇ
             -------------------------------------
           ‚Üí R P G‚ÇÅ G‚ÇÇ T‚ÇÇ

  data Interior {n : Level} (P : SType ‚Üí SType ‚Üí Set)
               : Type ‚Üí Type ‚Üí Type ‚Üí Type ‚Üí Set‚ÇÅ where
    inter : ‚àÄ{G‚ÇÅ G‚ÇÇ G‚ÇÉ G‚ÇÑ}
          ‚Üí Abs (L P G‚ÇÅ G‚ÇÇ) G‚ÇÉ
          ‚Üí Abs (R P G‚ÇÅ G‚ÇÇ) G‚ÇÑ
            ----------------------
          ‚Üí Interior P G‚ÇÅ G‚ÇÇ G‚ÇÉ G‚ÇÑ

  data STypeEq (A : SType) (B : SType) : Set where
    stype-eq : A ‚â° B ‚Üí STypeEq A B

  L=‚Üícc : ‚àÄ{G‚ÇÅ G‚ÇÇ T} ‚Üí L STypeEq G‚ÇÅ G‚ÇÇ T ‚Üí Conc G‚ÇÅ T √ó Conc G‚ÇÇ T
  L=‚Üícc (leftp x x‚ÇÅ (stype-eq refl)) = ‚ü® x , x‚ÇÅ ‚ü©

  cc‚ÜíL= : ‚àÄ{G‚ÇÅ G‚ÇÇ T} ‚Üí Conc G‚ÇÅ T ‚Üí Conc G‚ÇÇ T ‚Üí L STypeEq G‚ÇÅ G‚ÇÇ T
  cc‚ÜíL= g1t g2t = leftp g1t g2t (stype-eq refl)

  R=‚Üícc : ‚àÄ{G‚ÇÅ G‚ÇÇ T} ‚Üí R STypeEq G‚ÇÅ G‚ÇÇ T ‚Üí Conc G‚ÇÅ T √ó Conc G‚ÇÇ T
  R=‚Üícc (rightp x x‚ÇÅ (stype-eq refl)) = ‚ü® x , x‚ÇÅ ‚ü©

  cc‚ÜíR= : ‚àÄ{G‚ÇÅ G‚ÇÇ T} ‚Üí Conc G‚ÇÅ T ‚Üí Conc G‚ÇÇ T ‚Üí R STypeEq G‚ÇÅ G‚ÇÇ T
  cc‚ÜíR= g1t g2t = rightp g1t g2t (stype-eq refl)


  cct-consis : ‚àÄ{G1 G2 T} ‚Üí Conc G1 T ‚Üí Conc G2 T ‚Üí G1 ~ G2
  cct-consis c-base c-base = base~
  cct-consis c-base c-unk = unk~R
  cct-consis (c-fun c1t c1t‚ÇÅ) (c-fun c2t c2t‚ÇÅ) =
      fun~ (cct-consis c1t c2t) (cct-consis c1t‚ÇÅ c2t‚ÇÅ)
  cct-consis (c-fun c1t c1t‚ÇÅ) c-unk = unk~R
  cct-consis (c-pair c1t c1t‚ÇÅ) (c-pair c2t c2t‚ÇÅ) =
      pair~ (cct-consis c1t c2t) (cct-consis c1t‚ÇÅ c2t‚ÇÅ)
  cct-consis (c-pair c1t c1t‚ÇÅ) c-unk = unk~R
  cct-consis (c-sum c1t c1t‚ÇÅ) (c-sum c2t c2t‚ÇÅ) =
      sum~ (cct-consis c1t c2t) (cct-consis c1t‚ÇÅ c2t‚ÇÅ)
  cct-consis (c-sum c1t c1t‚ÇÅ) c-unk = unk~R
  cct-consis c-unk c2t = unk~L

  cct-c‚äî : ‚àÄ{G1 G2 T} ‚Üí (c1 : Conc G1 T) ‚Üí (c2 : Conc G2 T)
           ‚Üí Conc ((G1 ‚äî G2){cct-consis c1 c2}) T
  cct-c‚äî c-base c-base = c-base
  cct-c‚äî c-base c-unk = c-base
  cct-c‚äî (c-fun c1t c1t‚ÇÅ) (c-fun c2t c2t‚ÇÅ) =
      c-fun (cct-c‚äî c1t c2t) (cct-c‚äî c1t‚ÇÅ c2t‚ÇÅ)
  cct-c‚äî (c-fun c1t c1t‚ÇÅ) c-unk = c-fun c1t c1t‚ÇÅ
  cct-c‚äî (c-pair c1t c1t‚ÇÅ) (c-pair c2t c2t‚ÇÅ) =
      c-pair (cct-c‚äî c1t c2t) (cct-c‚äî c1t‚ÇÅ c2t‚ÇÅ)
  cct-c‚äî (c-pair c1t c1t‚ÇÅ) c-unk = c-pair c1t c1t‚ÇÅ
  cct-c‚äî (c-sum c1t c1t‚ÇÅ) (c-sum c2t c2t‚ÇÅ) =
      c-sum (cct-c‚äî c1t c2t) (cct-c‚äî c1t‚ÇÅ c2t‚ÇÅ)
  cct-c‚äî (c-sum c1t c1t‚ÇÅ) c-unk = c-sum c1t c1t‚ÇÅ
  cct-c‚äî c-unk c2t = c2t

  c‚äî-cct : ‚àÄ{G1 G2 T c} ‚Üí Conc ((G1 ‚äî G2){c}) T
         ‚Üí (Conc G1 T √ó Conc G2 T)
  c‚äî-cct {.‚ãÜ} {G2} {T} {unk~L} ct = ‚ü® c-unk , ct ‚ü©
  c‚äî-cct {G1} {.‚ãÜ} {T} {unk~R} ct = ‚ü® ct , c-unk ‚ü©
  c‚äî-cct {.(` _)} {.(` _)} {T} {base~} ct = ‚ü® ct , ct ‚ü©
  c‚äî-cct {A‚ÇÅ ‚áí A‚ÇÇ} {B‚ÇÅ ‚áí B‚ÇÇ} {T‚ÇÅ ‚áí T‚ÇÇ} {fun~ c c‚ÇÅ} (c-fun ct ct‚ÇÅ) =
    ‚ü® (c-fun (proj‚ÇÅ (c‚äî-cct {A‚ÇÅ}{B‚ÇÅ}{T‚ÇÅ}{c} ct))
             (proj‚ÇÅ (c‚äî-cct{A‚ÇÇ}{B‚ÇÇ}{T‚ÇÇ}{c‚ÇÅ} ct‚ÇÅ))) ,
      (c-fun (proj‚ÇÇ (c‚äî-cct {A‚ÇÅ}{B‚ÇÅ}{T‚ÇÅ}{c} ct))
             (proj‚ÇÇ (c‚äî-cct{A‚ÇÇ}{B‚ÇÇ}{T‚ÇÇ}{c‚ÇÅ} ct‚ÇÅ))) ‚ü©
  c‚äî-cct {A‚ÇÅ `√ó A‚ÇÇ} {B‚ÇÅ `√ó B‚ÇÇ} {T‚ÇÅ `√ó T‚ÇÇ} {pair~ c c‚ÇÅ} (c-pair ct ct‚ÇÅ) = 
    ‚ü® (c-pair (proj‚ÇÅ (c‚äî-cct {A‚ÇÅ}{B‚ÇÅ}{T‚ÇÅ}{c} ct))
             (proj‚ÇÅ (c‚äî-cct{A‚ÇÇ}{B‚ÇÇ}{T‚ÇÇ}{c‚ÇÅ} ct‚ÇÅ))) ,
      (c-pair (proj‚ÇÇ (c‚äî-cct {A‚ÇÅ}{B‚ÇÅ}{T‚ÇÅ}{c} ct))
             (proj‚ÇÇ (c‚äî-cct{A‚ÇÇ}{B‚ÇÇ}{T‚ÇÇ}{c‚ÇÅ} ct‚ÇÅ))) ‚ü©
  c‚äî-cct {A‚ÇÅ `‚äé A‚ÇÇ} {B‚ÇÅ `‚äé B‚ÇÇ} {T‚ÇÅ `‚äé T‚ÇÇ} {sum~ c c‚ÇÅ} (c-sum ct ct‚ÇÅ) =
    ‚ü® (c-sum (proj‚ÇÅ (c‚äî-cct {A‚ÇÅ}{B‚ÇÅ}{T‚ÇÅ}{c} ct))
             (proj‚ÇÅ (c‚äî-cct{A‚ÇÇ}{B‚ÇÇ}{T‚ÇÇ}{c‚ÇÅ} ct‚ÇÅ))) ,
      (c-sum (proj‚ÇÇ (c‚äî-cct {A‚ÇÅ}{B‚ÇÅ}{T‚ÇÅ}{c} ct))
             (proj‚ÇÇ (c‚äî-cct{A‚ÇÇ}{B‚ÇÇ}{T‚ÇÇ}{c‚ÇÅ} ct‚ÇÅ))) ‚ü©

  _iff_ : Set ‚Üí Set ‚Üí Set
  P iff Q = (P ‚Üí Q) √ó (Q ‚Üí P)

  prop-17 : ‚àÄ{G1 G2 T} ‚Üí
     (Œ£[ c ‚àà G1 ~ G2 ] Conc ((G1 ‚äî G2){c}) T) iff (Conc G1 T √ó Conc G2 T)
  prop-17 {G1}{G2}{T} = ‚ü® G , H ‚ü©
    where G : Œ£-syntax (G1 ~ G2) (Œª c ‚Üí Conc ((G1 ‚äî G2){c}) T) ‚Üí
               Conc G1 T √ó Conc G2 T
          G ‚ü® fst , snd ‚ü© = c‚äî-cct {G1}{G2}{T}{fst} snd

          H : Conc G1 T √ó Conc G2 T ‚Üí
                 Œ£-syntax (G1 ~ G2) (Œª c ‚Üí Conc ((G1 ‚äî G2){c}) T)
          H ‚ü® fst , snd ‚ü© = ‚ü® (cct-consis fst snd) , (cct-c‚äî fst snd) ‚ü©


{-

    Coordinate Concretization and Abstraction

   -}
{-
  data Conc2 : Type ‚Üí Type ‚Üí SType ‚Üí SType ‚Üí Set where
    conc2 : ‚àÄ{G‚ÇÅ G‚ÇÇ : Type} { T‚ÇÅ T‚ÇÇ : SType}
          ‚Üí Conc G‚ÇÅ T‚ÇÅ ‚Üí Conc G‚ÇÇ T‚ÇÇ
            -----------------------
          ‚Üí Conc2 G‚ÇÅ G‚ÇÇ T‚ÇÅ T‚ÇÇ

  data Proj‚ÇÅ {n m : Level} (P : SType ‚Üí SType ‚Üí Set n)
             (P‚ÇÅ : SType ‚Üí Set m) : Set (Agda.Primitive._‚äî_ n m) where
    proj-1 : 
        (‚àÄ{T‚ÇÅ} ‚Üí P‚ÇÅ T‚ÇÅ ‚Üí Œ£[ T‚ÇÇ ‚àà SType ] P T‚ÇÅ T‚ÇÇ)
      ‚Üí (‚àÄ{T‚ÇÅ T‚ÇÇ} ‚Üí P T‚ÇÅ T‚ÇÇ ‚Üí P‚ÇÅ T‚ÇÅ)
        -----------------------------------------
      ‚Üí Proj‚ÇÅ P P‚ÇÅ

  data Proj‚ÇÇ {n m : Level} (P : SType ‚Üí SType ‚Üí Set n)
             (P‚ÇÇ : SType ‚Üí Set m) : Set (Agda.Primitive._‚äî_ n m) where
    proj-2 : 
        (‚àÄ{T‚ÇÇ} ‚Üí P‚ÇÇ T‚ÇÇ ‚Üí Œ£[ T‚ÇÅ ‚àà SType ] P T‚ÇÅ T‚ÇÇ)
      ‚Üí (‚àÄ{T‚ÇÅ T‚ÇÇ} ‚Üí P T‚ÇÅ T‚ÇÇ ‚Üí P‚ÇÇ T‚ÇÇ)
        -----------------------------------------
      ‚Üí Proj‚ÇÇ P P‚ÇÇ

  data Abs2 {n : Level} (P : SType ‚Üí SType ‚Üí Set n)
            : Type ‚Üí Type ‚Üí Set (lsuc n) where
    abs2 : ‚àÄ {P‚ÇÅ P‚ÇÇ} {G‚ÇÅ G‚ÇÇ}
         ‚Üí Proj‚ÇÅ P P‚ÇÅ  ‚Üí  Abs P‚ÇÅ G‚ÇÅ
         ‚Üí Proj‚ÇÇ P P‚ÇÇ  ‚Üí  Abs P‚ÇÇ G‚ÇÇ
           ------------------------
         ‚Üí Abs2 P G‚ÇÅ G‚ÇÇ

  data And {n m : Level } (P : Set n) (Q : Set m)
           : Set (Agda.Primitive._‚äî_ n m) where
    mkAnd : P ‚Üí Q ‚Üí And P Q

  conc2p : {n : Level} ‚Üí (SType ‚Üí SType ‚Üí Set n) ‚Üí Type ‚Üí Type
         ‚Üí SType ‚Üí SType ‚Üí Set n
  conc2p P G‚ÇÅ G‚ÇÇ S‚ÇÅ S‚ÇÇ = And (Conc2 G‚ÇÅ G‚ÇÇ S‚ÇÅ S‚ÇÇ) (P S‚ÇÅ S‚ÇÇ)

  data Interior' {n : Level} (P : SType ‚Üí SType ‚Üí Set n)
               : Type ‚Üí Type ‚Üí Type ‚Üí Type ‚Üí Set (lsuc n) where
    inter : ‚àÄ{G‚ÇÅ G‚ÇÇ G‚ÇÉ G‚ÇÑ}
          ‚Üí Abs2 (conc2p P G‚ÇÅ G‚ÇÇ) G‚ÇÉ G‚ÇÑ
            ---------------------------
          ‚Üí Interior' P G‚ÇÅ G‚ÇÇ G‚ÇÉ G‚ÇÑ


  I= : Type ‚Üí Type ‚Üí Type ‚Üí Type ‚Üí Set‚ÇÅ 
  I= = Interior' STypeEq

  conc2= : Type ‚Üí Type ‚Üí SType ‚Üí SType ‚Üí Set
  conc2= G‚ÇÅ G‚ÇÇ S‚ÇÅ S‚ÇÇ = And (Conc2 G‚ÇÅ G‚ÇÇ S‚ÇÅ S‚ÇÇ) (STypeEq S‚ÇÅ S‚ÇÇ)

{-
  p1-conc2= : Type ‚Üí SType ‚Üí Set
  p1-conc2= G‚ÇÅ S‚ÇÅ = And (Conc G‚ÇÅ S‚ÇÅ) (STypeEq S‚ÇÅ S‚ÇÇ)
-}

  conc2ii : ‚àÄ{Œπ} ‚Üí Conc2 (` Œπ) (` Œπ) (` Œπ) (` Œπ)
  conc2ii {Œπ} = conc2 c-base c-base

  stypeii : ‚àÄ{Œπ} ‚Üí STypeEq (` Œπ) (` Œπ)
  stypeii {Œπ} = stype-eq refl

  conc2=ii : ‚àÄ{Œπ} ‚Üí conc2= (` Œπ) (` Œπ) (` Œπ) (` Œπ)
  conc2=ii {Œπ} = mkAnd conc2ii stypeii

{-
  data IsBase (Œπ : Base) : SType ‚Üí Set where
    eq-base : ‚àÄ{A : SType} ‚Üí A ‚â° ` Œπ ‚Üí IsBase Œπ A 

  I=ii : ‚àÄ {Œπ} ‚Üí I= (` Œπ) (` Œπ) (` Œπ) (` Œπ)
  I=ii {Œπ} = inter (abs2 (proj-1 {!!} {!!})
                         (abs-base {!!})
                         (proj-2 {!!} {!!})
                         (abs-base {!!}))

  prop-16 : ‚àÄ {G‚ÇÅ G‚ÇÇ} ‚Üí (c : G‚ÇÅ ~ G‚ÇÇ) ‚Üí I= G‚ÇÅ G‚ÇÇ ((G‚ÇÅ ‚äî G‚ÇÇ){c}) ((G‚ÇÅ ‚äî G‚ÇÇ){c})
  prop-16 unk~L = {!!}
  prop-16 unk~R = {!!}
  prop-16 (base~ {Œπ}) = inter (abs2 (proj-1 {!!} {!!}) (abs-base {!!})
                                    (proj-2 {!!} {!!}) (abs-base {!!}))
  prop-16 (fun~ c c‚ÇÅ) = {!!}
  prop-16 (pair~ c c‚ÇÅ) = {!!}
  prop-16 (sum~ c c‚ÇÅ) = {!!}
-}
-}

  {- 

   In AGT with simple types, casts are a triple of types where the
   middle type is an upper bound of the source and target, which
   corresponds to the threesomes of Siek and Wadler (2010).

   -}

  data Cast : Type ‚Üí Set where
    _‚áí_‚áí_ : (A : Type) ‚Üí (B : Type) ‚Üí (C : Type)
          ‚Üí {ab : A ‚äë B } ‚Üí {cb : C ‚äë B} ‚Üí Cast (A ‚áí C)
    error : (A : Type) ‚Üí (B : Type) ‚Üí Cast (A ‚áí B)

  import ParamCastCalculus
  module CastCalc = ParamCastCalculus Cast
  open CastCalc
  
  {-

   The identity casts (at base type) and error casts are active. All
   the other casts are inert. This treatment of identity casts as
   active is a bit different from the AGT paper, but I think it is
   nicer.

   -}

  data Inert : ‚àÄ{A} ‚Üí Cast A ‚Üí Set where
    inert : ‚àÄ{A B C} {ab : A ‚äë B} {cb : C ‚äë B}
          ‚Üí ¬¨ (Œ£[ Œπ ‚àà Base ] A ‚â° ` Œπ √ó C ‚â° ` Œπ)
          ‚Üí Inert ((A ‚áí B ‚áí C){ab}{cb})

  data Active : ‚àÄ{A} ‚Üí Cast A ‚Üí Set where
    activeId : ‚àÄ {Œπ : Base}{ab}{cb} ‚Üí Active (((` Œπ) ‚áí (` Œπ) ‚áí (` Œπ)){ab}{cb})
    activeError : ‚àÄ {A B} ‚Üí Active (error A B)


  baseAndEq? : (A : Type) ‚Üí (B : Type) ‚Üí Dec (Œ£[ Œπ ‚àà Base ] A ‚â° ` Œπ √ó B ‚â° ` Œπ)
  baseAndEq? A B
      with base? A | base? B
  ... | yes ba | no bb = no G
        where G : ¬¨ Œ£ Base (Œª Œπ ‚Üí Œ£ (A ‚â° ` Œπ) (Œª x ‚Üí B ‚â° ` Œπ))
              G ‚ü® fst‚ÇÅ , ‚ü® _ , snd‚ÇÅ ‚ü© ‚ü© =
                 contradiction ‚ü® fst‚ÇÅ , snd‚ÇÅ ‚ü© bb
  ... | no ba | _ = no G
        where G : ¬¨ Œ£ Base (Œª Œπ ‚Üí Œ£ (A ‚â° ` Œπ) (Œª x ‚Üí B ‚â° ` Œπ))
              G ‚ü® fst‚ÇÅ , ‚ü® fst‚ÇÇ , _ ‚ü© ‚ü© =
                 contradiction ‚ü® fst‚ÇÅ , fst‚ÇÇ ‚ü© ba
  ... | yes ‚ü® Œπ‚ÇÅ , refl ‚ü© | yes ‚ü® Œπ‚ÇÇ , refl ‚ü©
      with base-eq? Œπ‚ÇÅ Œπ‚ÇÇ
  ... | yes eq rewrite eq = yes ‚ü® Œπ‚ÇÇ , ‚ü® refl , refl ‚ü© ‚ü©
  ... | no neq = no G
      where G : ¬¨ Œ£ Base (Œª Œπ ‚Üí Œ£ (A ‚â° ` Œπ) (Œª x ‚Üí B ‚â° ` Œπ))
            G ‚ü® fst‚ÇÅ , ‚ü® refl , refl ‚ü© ‚ü© = neq refl

  ActiveOrInert : ‚àÄ{A} ‚Üí (c : Cast A) ‚Üí Active c ‚äé Inert c
  ActiveOrInert {.(A ‚áí C)} ((A ‚áí B ‚áí C){ab}{cb})
      with baseAndEq? A C
  ... | no nbe = inj‚ÇÇ (inert nbe)
  ... | yes ‚ü® Œπ , ‚ü® A‚â°Œπ , C‚â°Œπ ‚ü© ‚ü© rewrite A‚â°Œπ | C‚â°Œπ
      with ‚äëRBase cb
  ... | b=c rewrite b=c = inj‚ÇÅ activeId
  ActiveOrInert {.(A ‚áí B)} (error A B) = inj‚ÇÅ activeError

  import EfficientParamCasts
  module EPCR = EfficientParamCasts Cast Inert Active ActiveOrInert
  open EPCR
  
  applyCast : ‚àÄ {Œì A B} ‚Üí (M : Œì ‚ä¢ A) ‚Üí (Value M) ‚Üí (c : Cast (A ‚áí B))
            ‚Üí ‚àÄ {a : Active c} ‚Üí Œì ‚ä¢ B
  applyCast M v .(_ ‚áí _ ‚áí _) {activeId} = M
  applyCast M v (error _ _) {activeError} = blame (pos zero)

  funCast : ‚àÄ {Œì A A' B'} ‚Üí (M : Œì ‚ä¢ A) ‚Üí SimpleValue M
          ‚Üí (c : Cast (A ‚áí (A' ‚áí B'))) ‚Üí ‚àÄ {i : Inert c} ‚Üí Œì ‚ä¢ A' ‚Üí Œì ‚ä¢ B'
  funCast M v ((A ‚áí B ‚áí (C‚ÇÅ ‚áí C‚ÇÇ)){ab}{cb}) {inert _} N
      with ‚äëR‚áí cb
  ... | ‚ü® B‚ÇÅ , ‚ü® B‚ÇÇ , ‚ü® b=b12 , ‚ü® c1‚äëb1 , c2‚äëb2 ‚ü© ‚ü© ‚ü© ‚ü© rewrite b=b12
      with ‚äëL‚áí ab
  ... | inj‚ÇÅ A‚â°‚ãÜ = contradiction A‚â°‚ãÜ (simple‚ãÜ M v)
  ... | inj‚ÇÇ ‚ü® A‚ÇÅ , ‚ü® A‚ÇÇ , ‚ü® A=A‚ÇÅ‚áíA‚ÇÇ , ‚ü® A1‚äëB1 , A2‚äëB2 ‚ü© ‚ü© ‚ü© ‚ü© rewrite A=A‚ÇÅ‚áíA‚ÇÇ =
     (M ¬∑ (N ‚ü® (C‚ÇÅ ‚áí B‚ÇÅ ‚áí A‚ÇÅ){c1‚äëb1}{A1‚äëB1} ‚ü©))
             ‚ü® (A‚ÇÇ ‚áí B‚ÇÇ ‚áí C‚ÇÇ){A2‚äëB2}{c2‚äëb2} ‚ü©
             
  fstCast : ‚àÄ {Œì A A' B'} ‚Üí (M : Œì ‚ä¢ A) ‚Üí SimpleValue M
            ‚Üí (c : Cast (A ‚áí (A' `√ó B'))) ‚Üí ‚àÄ {i : Inert c} ‚Üí Œì ‚ä¢ A'
  fstCast M v ((A ‚áí B ‚áí (C‚ÇÅ `√ó C‚ÇÇ)){ab}{cb}) {inert _}
      with ‚äëR√ó cb
  ... | ‚ü® B‚ÇÅ , ‚ü® B‚ÇÇ , ‚ü® b=b12 , ‚ü® c1‚äëb1 , c2‚äëb2 ‚ü© ‚ü© ‚ü© ‚ü© rewrite b=b12
      with ‚äëL√ó ab
  ... | inj‚ÇÅ A‚â°‚ãÜ = contradiction A‚â°‚ãÜ (simple‚ãÜ M v)
  ... | inj‚ÇÇ ‚ü® A‚ÇÅ , ‚ü® A‚ÇÇ , ‚ü® A=A‚ÇÅ√óA‚ÇÇ , ‚ü® A1‚äëB1 , A2‚äëB2 ‚ü© ‚ü© ‚ü© ‚ü© rewrite A=A‚ÇÅ√óA‚ÇÇ =
        (fst M) ‚ü® (A‚ÇÅ ‚áí B‚ÇÅ ‚áí C‚ÇÅ){A1‚äëB1}{c1‚äëb1} ‚ü©

  sndCast : ‚àÄ {Œì A A' B'} ‚Üí (M : Œì ‚ä¢ A) ‚Üí SimpleValue M
            ‚Üí (c : Cast (A ‚áí (A' `√ó B'))) ‚Üí ‚àÄ {i : Inert c} ‚Üí Œì ‚ä¢ B'
  sndCast M v ((A ‚áí B ‚áí (C‚ÇÅ `√ó C‚ÇÇ)){ab}{cb}) {inert _}
      with ‚äëR√ó cb
  ... | ‚ü® B‚ÇÅ , ‚ü® B‚ÇÇ , ‚ü® b=b12 , ‚ü® c1‚äëb1 , c2‚äëb2 ‚ü© ‚ü© ‚ü© ‚ü© rewrite b=b12
      with ‚äëL√ó ab
  ... | inj‚ÇÅ A‚â°‚ãÜ = contradiction A‚â°‚ãÜ (simple‚ãÜ M v)
  ... | inj‚ÇÇ ‚ü® A‚ÇÅ , ‚ü® A‚ÇÇ , ‚ü® A=A‚ÇÅ√óA‚ÇÇ , ‚ü® A1‚äëB1 , A2‚äëB2 ‚ü© ‚ü© ‚ü© ‚ü© rewrite A=A‚ÇÅ√óA‚ÇÇ =
        (snd M) ‚ü® (A‚ÇÇ ‚áí B‚ÇÇ ‚áí C‚ÇÇ){A2‚äëB2}{c2‚äëb2} ‚ü©

  caseCast : ‚àÄ {Œì A A' B' C} ‚Üí (L : Œì ‚ä¢ A) ‚Üí SimpleValue L
             ‚Üí (c : Cast (A ‚áí (A' `‚äé B')))
             ‚Üí ‚àÄ {i : Inert c} ‚Üí (Œì ‚ä¢ A' ‚áí C) ‚Üí (Œì ‚ä¢ B' ‚áí C) ‚Üí Œì ‚ä¢ C
  caseCast{C = C} L v ((A ‚áí B ‚áí (C‚ÇÅ `‚äé C‚ÇÇ)){ab}{cb}) {inert _} M N
      with ‚äëR‚äé cb
  ... | ‚ü® B‚ÇÅ , ‚ü® B‚ÇÇ , ‚ü® b=b12 , ‚ü® c1‚äëb1 , c2‚äëb2 ‚ü© ‚ü© ‚ü© ‚ü© rewrite b=b12
      with ‚äëL‚äé ab
  ... | inj‚ÇÅ A‚â°‚ãÜ = contradiction A‚â°‚ãÜ (simple‚ãÜ L v)
  ... | inj‚ÇÇ ‚ü® A‚ÇÅ , ‚ü® A‚ÇÇ , ‚ü® A=A‚ÇÅ‚äéA‚ÇÇ , ‚ü® a1‚äëb1 , a2‚äëb2 ‚ü© ‚ü© ‚ü© ‚ü© rewrite A=A‚ÇÅ‚äéA‚ÇÇ =
      case L (M ‚ü® ((C‚ÇÅ ‚áí C) ‚áí (B‚ÇÅ ‚áí C) ‚áí (A‚ÇÅ ‚áí C)){le1}{le2} ‚ü©)
             (N ‚ü® ((C‚ÇÇ ‚áí C) ‚áí (B‚ÇÇ ‚áí C) ‚áí (A‚ÇÇ ‚áí C)){le3}{le4} ‚ü©)
      where
      le1 = fun‚äë c1‚äëb1 Refl‚äë
      le2 = fun‚äë a1‚äëb1 Refl‚äë
      le3 = fun‚äë c2‚äëb2 Refl‚äë
      le4 = fun‚äë a2‚äëb2 Refl‚äë

  compose : ‚àÄ{A B C} ‚Üí Cast (A ‚áí B) ‚Üí Cast (B ‚áí C) ‚Üí Cast (A ‚áí C)
  compose ((A ‚áí B ‚áí C){ab}{cb}) ((C ‚áí B' ‚áí C'){cb'}{c'b'})
      with B `~ B'
  ... | no nc = error A C' 
  ... | yes B~B'
      with (B `‚äî B') {B~B'}
  ... | ‚ü® B‚äîB' , ‚ü® ‚ü® B‚äëB‚äîB' , B'‚äëB‚äîB' ‚ü© , lb ‚ü© ‚ü© =
         (A ‚áí B‚äîB' ‚áí C'){Trans‚äë ab B‚äëB‚äîB'}{Trans‚äë c'b' B'‚äëB‚äîB'}
  compose (A ‚áí B ‚áí C) (error C C') = (error A C')
  compose (error A B) (error B C) = (error A C)
  compose (error A B) (B ‚áí B' ‚áí C) = (error A C)

  baseNotInert : ‚àÄ {A Œπ} ‚Üí (c : Cast (A ‚áí ` Œπ)) ‚Üí A ‚â¢ ‚ãÜ ‚Üí ¬¨ Inert c
  baseNotInert ((A ‚áí B ‚áí (` Œπ)){ab}{cb}) A‚â¢‚ãÜ (inert p)
      with ‚äëRBase cb
  ... | b‚â°c rewrite b‚â°c
      with ‚äëLBase ab
  ... | inj‚ÇÅ eq rewrite eq = p ‚ü® Œπ , ‚ü® refl , refl ‚ü© ‚ü©
  ... | inj‚ÇÇ eq‚ãÜ = contradiction eq‚ãÜ A‚â¢‚ãÜ
  baseNotInert (error A B) A‚ãÜ = Œª ()

  module Red = EPCR.Reduction applyCast funCast fstCast sndCast caseCast
                  baseNotInert compose
  open Red


